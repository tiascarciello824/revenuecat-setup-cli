/**
 * RevenueCat Webhook Handler Template (Supabase Edge Function)
 * Based on: conserva/supabase/functions/handle-revenuecat-webhook/index.ts
 */

export const webhookTemplate = `/**
 * RevenueCat Webhook Handler (Supabase Edge Function)
 * Generated by RevenueCat Setup CLI
 * Project: {{PROJECT_NAME}}
 *
 * Handles webhook events from RevenueCat to keep subscription status in sync
 * Events: INITIAL_PURCHASE, RENEWAL, CANCELLATION, EXPIRATION, etc.
 *
 * Deploy command:
 * supabase functions deploy {{FUNCTION_NAME}}
 *
 * Webhook URL format:
 * https://[PROJECT_REF].supabase.co/functions/v1/{{FUNCTION_NAME}}
 */

import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
import { createHmac } from 'https://deno.land/std@0.168.0/node/crypto.ts';

// Types for RevenueCat webhook payloads
interface RevenueCatEvent {
  api_version: string;
  event: {
    id: string;
    type: string;
    app_user_id: string;
    aliases: string[];
    original_app_user_id: string;
    product_id: string;
    entitlement_ids: string[];
    period_type: string;
    purchased_at_ms: number;
    expiration_at_ms: number | null;
    store: string;
    environment: string;
    is_family_share: boolean;
    country_code: string;
    price: number | null;
    currency: string | null;
    is_trial_conversion: boolean;
    cancel_reason: string | null;
  };
}

// Validate webhook signature using HMAC SHA256
function validateWebhookSignature(
  payload: string,
  signature: string | null,
  secret: string
): boolean {
  if (!signature) {
    console.error('❌ No signature provided');
    return false;
  }

  try {
    const providedSignature = signature.startsWith('sha256=')
      ? signature.substring(7)
      : signature;

    const expectedSignature = createHmac('sha256', secret)
      .update(payload)
      .digest('hex');

    return providedSignature === expectedSignature;
  } catch (error) {
    console.error('❌ Error validating signature:', error);
    return false;
  }
}

// Map RevenueCat event type to subscription status
function getSubscriptionStatus(eventType: string, periodType: string): string {
  switch (eventType) {
    case 'INITIAL_PURCHASE':
      return periodType === 'TRIAL' ? 'trial' : 'active';
    case 'RENEWAL':
      return 'active';
    case 'CANCELLATION':
      return 'cancelled';
    case 'EXPIRATION':
      return 'expired';
    case 'NON_RENEWING_PURCHASE':
      return 'active';
    default:
      return 'active';
  }
}

// Main handler function
serve(async (req) => {
  if (req.method !== 'POST') {
    return new Response(JSON.stringify({ error: 'Method not allowed' }), {
      status: 405,
      headers: { 'Content-Type': 'application/json' },
    });
  }

  try {
    const webhookSecret = Deno.env.get('SUPABASE_REVENUECAT_WEBHOOK_SECRET');

    if (!webhookSecret || webhookSecret === 'YOUR_WEBHOOK_SECRET_HERE') {
      console.error('❌ Webhook secret not configured');
      return new Response(
        JSON.stringify({ error: 'Webhook secret not configured' }),
        {
          status: 500,
          headers: { 'Content-Type': 'application/json' },
        }
      );
    }

    const payload = await req.text();
    const signature = req.headers.get('X-RevenueCat-Signature');
    const isValid = validateWebhookSignature(payload, signature, webhookSecret);

    if (!isValid) {
      console.error('❌ Invalid webhook signature');
      return new Response(JSON.stringify({ error: 'Invalid signature' }), {
        status: 401,
        headers: { 'Content-Type': 'application/json' },
      });
    }

    const data: RevenueCatEvent = JSON.parse(payload);
    const { event } = data;

    console.log('✅ Received RevenueCat webhook:', {
      eventId: event.id,
      eventType: event.type,
      userId: event.app_user_id,
      productId: event.product_id,
      periodType: event.period_type,
    });

    const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
    const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
    const supabase = createClient(supabaseUrl, supabaseServiceKey);

    const userId = event.app_user_id;
    const hasPro = event.entitlement_ids.includes('{{ENTITLEMENT_ID}}');
    const tier = hasPro ? 'pro' : 'free';
    const status = getSubscriptionStatus(event.type, event.period_type);

    const profileUpdates: any = {
      subscription_tier: tier,
      subscription_status: status,
      revenue_cat_customer_id: event.original_app_user_id,
      updated_at: new Date().toISOString(),
    };

    if (event.period_type === 'TRIAL' && event.expiration_at_ms) {
      const trialEndDate = new Date(event.expiration_at_ms);
      const trialStartDate = new Date(event.purchased_at_ms);

      profileUpdates.trial_start_date = trialStartDate.toISOString();
      profileUpdates.trial_end_date = trialEndDate.toISOString();
    }

    if (hasPro) {
      profileUpdates.subscription_start_date = new Date(
        event.purchased_at_ms
      ).toISOString();

      if (event.expiration_at_ms) {
        profileUpdates.subscription_end_date = new Date(
          event.expiration_at_ms
        ).toISOString();
      }
    }

    const { error: profileError } = await supabase
      .from('profiles')
      .update(profileUpdates)
      .eq('user_id', userId);

    if (profileError) {
      console.error('❌ Failed to update profile:', profileError);
      throw profileError;
    }

    console.log('✅ Updated profile:', userId, profileUpdates);

    const subscriptionRecord = {
      user_id: userId,
      revenue_cat_transaction_id: event.id,
      product_identifier: event.product_id,
      purchase_date: new Date(event.purchased_at_ms).toISOString(),
      expiration_date: event.expiration_at_ms
        ? new Date(event.expiration_at_ms).toISOString()
        : null,
      is_active: hasPro && status === 'active',
      is_trial: event.period_type === 'TRIAL',
      cancellation_date:
        event.type === 'CANCELLATION' ? new Date().toISOString() : null,
      raw_revenue_cat_data: data,
      updated_at: new Date().toISOString(),
    };

    const { error: subscriptionError } = await supabase
      .from('user_subscriptions')
      .upsert(subscriptionRecord, {
        onConflict: 'revenue_cat_transaction_id',
      });

    if (subscriptionError) {
      console.error('❌ Failed to upsert subscription:', subscriptionError);
      throw subscriptionError;
    }

    console.log('✅ Upserted subscription record:', event.id);

    return new Response(
      JSON.stringify({
        success: true,
        eventId: event.id,
        eventType: event.type,
        userId,
        tier,
        status,
      }),
      {
        status: 200,
        headers: { 'Content-Type': 'application/json' },
      }
    );
  } catch (error) {
    console.error('❌ Webhook error:', error);

    return new Response(
      JSON.stringify({
        error: 'Internal server error',
        message: error.message,
      }),
      {
        status: 500,
        headers: { 'Content-Type': 'application/json' },
      }
    );
  }
});
`;
