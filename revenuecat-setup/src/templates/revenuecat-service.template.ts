/**
 * RevenueCat Service Template
 * Based on: conserva/lib/services/revenuecat.ts
 */

export const revenueCatServiceTemplate = `/**
 * RevenueCat Service
 * Generated by RevenueCat Setup CLI
 * Project: {{PROJECT_NAME}}
 *
 * Handles all subscription logic via RevenueCat SDK
 * - Initialize SDK
 * - Fetch offerings
 * - Purchase subscriptions
 * - Restore purchases
 {{#if HAS_SUPABASE}}- Sync with Supabase{{/if}}
 */

import Purchases, {
  CustomerInfo,
  PurchasesOfferings,
  PurchasesPackage,
  LOG_LEVEL,
} from 'react-native-purchases';
import { Platform } from 'react-native';
{{#if HAS_SUPABASE}}import { supabase } from '@/lib/supabase/client';{{/if}}
{{#if HAS_TYPES}}import type { SubscriptionTier, SubscriptionStatus } from '@/types';{{/if}}

// Product identifiers (must match RevenueCat Dashboard and App Store Connect / Google Play Console)
export const PRODUCT_IDS = {
{{#each PRODUCTS}}
  {{CONSTANT_NAME}}: '{{PRODUCT_ID}}',
{{/each}}
} as const;

// Entitlement identifier (configured in RevenueCat Dashboard)
export const ENTITLEMENT_ID = '{{ENTITLEMENT_ID}}';

/**
 * Initialize RevenueCat SDK
 * Call this once at app startup
 */
export async function initializeRevenueCat(userId?: string): Promise<void> {
  try {
    // Get API keys from environment
    const apiKey = Platform.select({
      ios: process.env.{{IOS_ENV_VAR}},
      android: process.env.{{ANDROID_ENV_VAR}},
    });

    if (!apiKey || apiKey === 'YOUR_IOS_KEY_HERE' || apiKey === 'YOUR_ANDROID_KEY_HERE') {
      console.warn('‚ö†Ô∏è RevenueCat API key not configured. Subscription features will be limited.');
      return;
    }

    // Configure SDK
    Purchases.setLogLevel(LOG_LEVEL.DEBUG); // Use LOG_LEVEL.INFO in production

    // Initialize
    await Purchases.configure({ apiKey });

    // Set user ID if available (for cross-device subscription sync)
    if (userId) {
      await Purchases.logIn(userId);
    }

    // Set up customer info listener
    Purchases.addCustomerInfoUpdateListener(handleCustomerInfoUpdate);

    console.log('‚úÖ RevenueCat initialized successfully');
  } catch (error) {
    console.error('‚ùå Failed to initialize RevenueCat:', error);
    throw error;
  }
}

/**
 * Login user to RevenueCat (for cross-device sync)
 * Call this after user signs in
 */
export async function loginToRevenueCat(userId: string): Promise<CustomerInfo> {
  try {
    const { customerInfo } = await Purchases.logIn(userId);
    console.log('‚úÖ Logged in to RevenueCat:', userId);
    return customerInfo;
  } catch (error) {
    console.error('‚ùå Failed to login to RevenueCat:', error);
    throw error;
  }
}

/**
 * Logout user from RevenueCat
 * Call this after user signs out
 */
export async function logoutFromRevenueCat(): Promise<void> {
  try {
    await Purchases.logOut();
    console.log('‚úÖ Logged out from RevenueCat');
  } catch (error) {
    console.error('‚ùå Failed to logout from RevenueCat:', error);
    // Don't throw - logout should always succeed
  }
}

/**
 * Get current offerings from RevenueCat
 * Returns available subscription packages
 */
export async function getOfferings(): Promise<PurchasesOfferings | null> {
  try {
    const offerings = await Purchases.getOfferings();

    if (offerings.current === null) {
      console.warn('‚ö†Ô∏è No offerings available from RevenueCat');
      return null;
    }

    console.log('‚úÖ Fetched offerings:', offerings.current.identifier);
    return offerings;
  } catch (error) {
    console.error('‚ùå Failed to fetch offerings:', error);
    return null;
  }
}

/**
 * Purchase a subscription package
 * @param pkg - The package to purchase (from offerings)
 * @returns CustomerInfo with updated entitlements
 */
export async function purchasePackage(pkg: PurchasesPackage): Promise<CustomerInfo> {
  try {
    console.log('üõí Initiating purchase:', pkg.identifier);

    const { customerInfo } = await Purchases.purchasePackage(pkg);

    console.log('‚úÖ Purchase successful:', pkg.identifier);
    console.log('Entitlements:', Object.keys(customerInfo.entitlements.active));

    {{#if HAS_SUPABASE}}// Sync with Supabase
    await syncCustomerInfoWithSupabase(customerInfo);
    {{/if}}

    return customerInfo;
  } catch (error: any) {
    console.error('‚ùå Purchase failed:', error);

    // Handle user cancellation gracefully
    if (error.userCancelled) {
      console.log('‚ÑπÔ∏è User cancelled purchase');
      throw new Error('PURCHASE_CANCELLED');
    }

    throw error;
  }
}

/**
 * Restore previous purchases
 * Use this for users who already purchased on another device
 */
export async function restorePurchases(): Promise<CustomerInfo> {
  try {
    console.log('üîÑ Restoring purchases...');

    const customerInfo = await Purchases.restorePurchases();

    console.log('‚úÖ Purchases restored');
    console.log('Active entitlements:', Object.keys(customerInfo.entitlements.active));

    {{#if HAS_SUPABASE}}// Sync with Supabase
    await syncCustomerInfoWithSupabase(customerInfo);
    {{/if}}

    return customerInfo;
  } catch (error) {
    console.error('‚ùå Failed to restore purchases:', error);
    throw error;
  }
}

/**
 * Get current customer info
 * Returns subscription status and entitlements
 */
export async function getCustomerInfo(): Promise<CustomerInfo> {
  try {
    const customerInfo = await Purchases.getCustomerInfo();
    return customerInfo;
  } catch (error) {
    console.error('‚ùå Failed to get customer info:', error);
    throw error;
  }
}

/**
 * Check if user has Pro entitlement
 */
export function hasProEntitlement(customerInfo: CustomerInfo): boolean {
  const entitlement = customerInfo.entitlements.active[ENTITLEMENT_ID];
  return entitlement !== undefined && entitlement.isActive;
}

{{#if HAS_TYPES}}/**
 * Get subscription tier from CustomerInfo
 */
export function getSubscriptionTier(customerInfo: CustomerInfo): SubscriptionTier {
  return hasProEntitlement(customerInfo) ? 'pro' : 'free';
}

/**
 * Get subscription status from CustomerInfo
 */
export function getSubscriptionStatus(customerInfo: CustomerInfo): SubscriptionStatus {
  const entitlement = customerInfo.entitlements.active[ENTITLEMENT_ID];

  if (!entitlement) {
    return 'active'; // Free tier is always "active"
  }

  // Check if in trial
  if (entitlement.willRenew && entitlement.periodType === 'trial') {
    return 'trial';
  }

  // Check if cancelled
  if (!entitlement.willRenew) {
    return 'cancelled';
  }

  // Check if expired
  const expirationDate = new Date(entitlement.expirationDate!);
  if (expirationDate < new Date()) {
    return 'expired';
  }

  return 'active';
}
{{/if}}

/**
 * Get trial end date from CustomerInfo
 */
export function getTrialEndDate(customerInfo: CustomerInfo): Date | null {
  const entitlement = customerInfo.entitlements.active[ENTITLEMENT_ID];

  if (!entitlement || entitlement.periodType !== 'trial') {
    return null;
  }

  return entitlement.expirationDate ? new Date(entitlement.expirationDate) : null;
}

/**
 * Calculate days remaining in trial
 */
export function getTrialDaysRemaining(customerInfo: CustomerInfo): number | null {
  const trialEndDate = getTrialEndDate(customerInfo);

  if (!trialEndDate) {
    return null;
  }

  const now = new Date();
  const diffTime = trialEndDate.getTime() - now.getTime();
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

  return Math.max(0, diffDays);
}

{{#if HAS_SUPABASE}}/**
 * Sync CustomerInfo with Supabase
 * Updates profiles table with subscription data
 */
export async function syncCustomerInfoWithSupabase(customerInfo: CustomerInfo): Promise<void> {
  try {
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      console.warn('‚ö†Ô∏è No authenticated user - skipping Supabase sync');
      return;
    }

    const tier = getSubscriptionTier(customerInfo);
    const status = getSubscriptionStatus(customerInfo);
    const entitlement = customerInfo.entitlements.active[ENTITLEMENT_ID];

    // Prepare update data
    const updates: any = {
      subscription_tier: tier,
      subscription_status: status,
      revenue_cat_customer_id: customerInfo.originalAppUserId,
      updated_at: new Date().toISOString(),
    };

    // Add trial dates if in trial
    if (status === 'trial' && entitlement) {
      const expirationDate = new Date(entitlement.expirationDate!);
      const trialStartDate = new Date(expirationDate);
      trialStartDate.setDate(trialStartDate.getDate() - 7); // Assuming 7-day trial

      updates.trial_start_date = trialStartDate.toISOString();
      updates.trial_end_date = expirationDate.toISOString();
    }

    // Add subscription dates for active pro users
    if (tier === 'pro' && entitlement) {
      updates.subscription_start_date = entitlement.originalPurchaseDate;
      updates.subscription_end_date = entitlement.expirationDate || null;
    }

    // Update Supabase
    const { error } = await supabase
      .from('profiles')
      .update(updates)
      .eq('user_id', user.id);

    if (error) {
      console.error('‚ùå Failed to sync with Supabase:', error);
      throw error;
    }

    console.log('‚úÖ Synced subscription data to Supabase');
    console.log('  Tier:', tier);
    console.log('  Status:', status);
  } catch (error) {
    console.error('‚ùå Supabase sync failed:', error);
    // Don't throw - subscription should work even if sync fails
  }
}
{{/if}}

/**
 * Customer info update listener
 * Called automatically when subscription status changes
 */
function handleCustomerInfoUpdate(customerInfo: CustomerInfo): void {
  console.log('üîî Customer info updated');
  console.log('Active entitlements:', Object.keys(customerInfo.entitlements.active));

  {{#if HAS_SUPABASE}}// Sync with Supabase
  syncCustomerInfoWithSupabase(customerInfo).catch((error) => {
    console.error('‚ùå Failed to sync customer info update:', error);
  });
  {{/if}}
}

/**
 * Check if RevenueCat is properly configured
 */
export function isRevenueCatConfigured(): boolean {
  const apiKey = Platform.select({
    ios: process.env.{{IOS_ENV_VAR}},
    android: process.env.{{ANDROID_ENV_VAR}},
  });

  return !!(apiKey && apiKey !== 'YOUR_IOS_KEY_HERE' && apiKey !== 'YOUR_ANDROID_KEY_HERE');
}
`;
