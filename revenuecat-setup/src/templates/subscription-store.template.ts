/**
 * Subscription Store Template (Zustand)
 * Based on: conserva/store/subscriptionStore.ts
 */

export const subscriptionStoreTemplate = `/**
 * Subscription Store
 * Generated by RevenueCat Setup CLI
 * Project: {{PROJECT_NAME}}
 *
 * Manages subscription state using Zustand
 * - Subscription tier (free/pro)
 * - Product limits
 * - Trial status
 * - RevenueCat integration
 */

import { create } from 'zustand';
import type { SubscriptionState, SubscriptionTier, SubscriptionStatus } from '@/types';
import {
  initializeRevenueCat,
  loginToRevenueCat,
  getCustomerInfo,
  getOfferings,
  purchasePackage,
  restorePurchases,
  {{#if HAS_SUPABASE}}syncCustomerInfoWithSupabase,{{/if}}
  getSubscriptionTier,
  getSubscriptionStatus,
  getTrialDaysRemaining,
  getTrialEndDate,
  hasProEntitlement,
  isRevenueCatConfigured,
} from '@/lib/services/revenuecat';
{{#if HAS_SUPABASE}}import { supabase } from '@/lib/supabase/client';{{/if}}
import type { CustomerInfo, PurchasesOfferings } from 'react-native-purchases';

// Constants
const FREE_TIER_LIMIT = {{FREE_TIER_LIMIT}};
const SOFT_WALL_THRESHOLD = {{SOFT_WALL_THRESHOLD}}; // Show warning at threshold

export const useSubscriptionStore = create<SubscriptionState>((set, get) => ({
  // ============= Initial State =============
  tier: 'free',
  status: 'loading',
  isLoading: true,
  error: null,

  productCount: 0,
  productLimit: FREE_TIER_LIMIT,
  canAddProduct: false,
  productsRemaining: FREE_TIER_LIMIT,

  isInTrial: false,
  trialDaysRemaining: null,
  trialEndDate: null,

  subscriptionStartDate: null,
  subscriptionEndDate: null,

  customerInfo: null,
  offerings: null,

  shouldShowSoftWall: false,
  shouldShowHardWall: false,

  // ============= Actions =============

  /**
   * Initialize subscription system
   * Call this once at app startup after auth is initialized
   */
  initialize: async () => {
    set({ isLoading: true, error: null });

    try {
      console.log('üîÑ Initializing subscription store...');

      {{#if HAS_SUPABASE}}// Get authenticated user
      const { data: { user } } = await supabase.auth.getUser();

      if (!user) {
        console.warn('‚ö†Ô∏è No authenticated user - defaulting to free tier');
        set({
          tier: 'free',
          status: 'active',
          isLoading: false,
          productLimit: FREE_TIER_LIMIT,
          canAddProduct: false,
          productsRemaining: FREE_TIER_LIMIT,
        });
        return;
      }

      // Check if RevenueCat is configured
      if (!isRevenueCatConfigured()) {
        console.warn('‚ö†Ô∏è RevenueCat not configured - using Supabase data only');
        await get().checkSubscriptionStatus();
        return;
      }

      // Initialize RevenueCat
      await initializeRevenueCat();

      // Login to RevenueCat with user ID
      await loginToRevenueCat(user.id);
      {{else}}
      // Check if RevenueCat is configured
      if (!isRevenueCatConfigured()) {
        console.warn('‚ö†Ô∏è RevenueCat not configured');
        set({
          tier: 'free',
          status: 'active',
          isLoading: false,
          productLimit: FREE_TIER_LIMIT,
        });
        return;
      }

      // Initialize RevenueCat
      await initializeRevenueCat();
      {{/if}}

      // Fetch customer info
      const customerInfo = await getCustomerInfo();
      set({ customerInfo });

      {{#if HAS_SUPABASE}}// Sync with Supabase
      await syncCustomerInfoWithSupabase(customerInfo);
      {{/if}}

      // Update local state from customer info
      await get()._updateFromCustomerInfo(customerInfo);

      // Fetch offerings
      const offerings = await getOfferings();
      set({ offerings });

      {{#if HAS_SUPABASE}}// Refresh product count
      await get().refreshProductCount();
      {{/if}}

      console.log('‚úÖ Subscription store initialized');
    } catch (error) {
      console.error('‚ùå Failed to initialize subscription store:', error);
      set({ error: error as Error });

      {{#if HAS_SUPABASE}}// Fallback to Supabase data
      await get().checkSubscriptionStatus();
      {{/if}}
    } finally {
      set({ isLoading: false });
    }
  },

  {{#if HAS_SUPABASE}}/**
   * Check subscription status from Supabase
   * Used as fallback when RevenueCat is unavailable
   */
  checkSubscriptionStatus: async () => {
    try {
      const { data: { user } } = await supabase.auth.getUser();

      if (!user) {
        set({
          tier: 'free',
          status: 'active',
          productLimit: FREE_TIER_LIMIT,
        });
        return;
      }

      // Fetch profile from Supabase
      const { data: profile, error } = await supabase
        .from('profiles')
        .select('*')
        .eq('user_id', user.id)
        .single();

      if (error || !profile) {
        console.warn('‚ö†Ô∏è No profile found - defaulting to free tier');
        set({
          tier: 'free',
          status: 'active',
          productLimit: FREE_TIER_LIMIT,
        });
        return;
      }

      // Update state from Supabase data
      const tier = (profile.subscription_tier || 'free') as SubscriptionTier;
      const status = (profile.subscription_status || 'active') as SubscriptionStatus;

      set({
        tier,
        status,
        productLimit: tier === 'pro' ? Infinity : FREE_TIER_LIMIT,
        trialEndDate: profile.trial_end_date ? new Date(profile.trial_end_date) : null,
        subscriptionStartDate: profile.subscription_start_date
          ? new Date(profile.subscription_start_date)
          : null,
        subscriptionEndDate: profile.subscription_end_date
          ? new Date(profile.subscription_end_date)
          : null,
      });

      // Calculate trial info
      get()._recalculateTrialInfo();

      console.log('‚úÖ Checked subscription status from Supabase');
      console.log('  Tier:', tier);
      console.log('  Status:', status);
    } catch (error) {
      console.error('‚ùå Failed to check subscription status:', error);
      set({ error: error as Error });
    }
  },
  {{/if}}

  /**
   * Purchase a subscription
   * @param packageId - Package identifier from offerings
   * @returns true if successful
   */
  purchaseSubscription: async (packageId: string) => {
    set({ isLoading: true, error: null });

    try {
      console.log('üõí Purchasing subscription:', packageId);

      // Get offerings
      let { offerings } = get();
      if (!offerings) {
        offerings = await getOfferings();
        set({ offerings });
      }

      if (!offerings?.current) {
        throw new Error('No offerings available');
      }

      // Find package
      const pkg = offerings.current.availablePackages.find(
        (p) => p.identifier === packageId
      );

      if (!pkg) {
        throw new Error(\`Package not found: \${packageId}\`);
      }

      // Purchase
      const customerInfo = await purchasePackage(pkg);
      set({ customerInfo });

      // Update state
      await get()._updateFromCustomerInfo(customerInfo);

      {{#if HAS_SUPABASE}}// Refresh product count
      await get().refreshProductCount();
      {{/if}}

      console.log('‚úÖ Purchase successful');
      return true;
    } catch (error: any) {
      console.error('‚ùå Purchase failed:', error);

      // Don't set error if user cancelled
      if (error.message !== 'PURCHASE_CANCELLED') {
        set({ error: error as Error });
      }

      return false;
    } finally {
      set({ isLoading: false });
    }
  },

  /**
   * Restore previous purchases
   * @returns true if successful and user has active subscription
   */
  restorePurchases: async () => {
    set({ isLoading: true, error: null });

    try {
      console.log('üîÑ Restoring purchases...');

      const customerInfo = await restorePurchases();
      set({ customerInfo });

      // Update state
      await get()._updateFromCustomerInfo(customerInfo);

      {{#if HAS_SUPABASE}}// Refresh product count
      await get().refreshProductCount();
      {{/if}}

      const hasPro = get().tier === 'pro';

      console.log('‚úÖ Purchases restored:', hasPro ? 'Pro found' : 'No active subscription');
      return hasPro;
    } catch (error) {
      console.error('‚ùå Failed to restore purchases:', error);
      set({ error: error as Error });
      return false;
    } finally {
      set({ isLoading: false });
    }
  },

  {{#if HAS_SUPABASE}}/**
   * Refresh product count from database
   * Updates canAddProduct, shouldShowSoftWall, shouldShowHardWall
   */
  refreshProductCount: async () => {
    try {
      const { data: { user } } = await supabase.auth.getUser();

      if (!user) {
        set({
          productCount: 0,
          productsRemaining: FREE_TIER_LIMIT,
          canAddProduct: false,
          shouldShowSoftWall: false,
          shouldShowHardWall: false,
        });
        return;
      }

      // Count active products
      const { count, error } = await supabase
        .from('products')
        .select('id', { count: 'exact', head: true })
        .eq('user_id', user.id)
        .eq('status', 'active');

      if (error) {
        console.error('‚ùå Failed to count products:', error);
        return;
      }

      const productCount = count || 0;
      const { tier, productLimit } = get();

      // Calculate remaining products
      const productsRemaining = Math.max(0, productLimit - productCount);

      // Determine if user can add more products
      const canAddProduct = tier === 'pro' || productCount < FREE_TIER_LIMIT;

      // Determine if we should show paywalls
      const shouldShowSoftWall = tier === 'free' && productCount >= SOFT_WALL_THRESHOLD;
      const shouldShowHardWall = tier === 'free' && productCount >= FREE_TIER_LIMIT;

      set({
        productCount,
        productsRemaining,
        canAddProduct,
        shouldShowSoftWall,
        shouldShowHardWall,
      });

      console.log('üìä Product count updated:', productCount, '/', productLimit);
      console.log('  Can add:', canAddProduct);
      console.log('  Soft wall:', shouldShowSoftWall);
      console.log('  Hard wall:', shouldShowHardWall);
    } catch (error) {
      console.error('‚ùå Failed to refresh product count:', error);
    }
  },

  /**
   * Sync with Supabase
   * Manually trigger sync with database
   */
  syncWithSupabase: async (customerInfo: CustomerInfo) => {
    try {
      await syncCustomerInfoWithSupabase(customerInfo);
      await get()._updateFromCustomerInfo(customerInfo);
      console.log('‚úÖ Synced with Supabase');
    } catch (error) {
      console.error('‚ùå Failed to sync with Supabase:', error);
    }
  },
  {{/if}}

  // ============= Internal Helper Methods =============

  /**
   * Update state from RevenueCat CustomerInfo
   * @private
   */
  _updateFromCustomerInfo: async (customerInfo: CustomerInfo) => {
    const tier = getSubscriptionTier(customerInfo);
    const status = getSubscriptionStatus(customerInfo);
    const trialDaysRemaining = getTrialDaysRemaining(customerInfo);
    const trialEndDate = getTrialEndDate(customerInfo);

    // Get dates from entitlement
    const entitlement = customerInfo.entitlements.active['{{ENTITLEMENT_ID}}'];
    const subscriptionStartDate = entitlement?.originalPurchaseDate
      ? new Date(entitlement.originalPurchaseDate)
      : null;
    const subscriptionEndDate = entitlement?.expirationDate
      ? new Date(entitlement.expirationDate)
      : null;

    set({
      tier,
      status,
      productLimit: tier === 'pro' ? Infinity : FREE_TIER_LIMIT,
      trialDaysRemaining,
      trialEndDate,
      subscriptionStartDate,
      subscriptionEndDate,
    });

    // Recalculate trial info
    get()._recalculateTrialInfo();
  },

  /**
   * Recalculate trial-related computed properties
   * @private
   */
  _recalculateTrialInfo: () => {
    const { status, trialEndDate } = get();

    const isInTrial = status === 'trial' && trialEndDate !== null && trialEndDate > new Date();

    // Recalculate days remaining
    let trialDaysRemaining: number | null = null;
    if (isInTrial && trialEndDate) {
      const now = new Date();
      const diffTime = trialEndDate.getTime() - now.getTime();
      const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
      trialDaysRemaining = Math.max(0, diffDays);
    }

    set({ isInTrial, trialDaysRemaining });
  },
}));
`;
